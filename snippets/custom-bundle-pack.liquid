<div class="bundle-selector">
  <h3 class="bundle-title">- Bundle promotion is valid till 11:59 PM -</h3>

  {% assign base_price = product.price %}
  {% assign compare_price = product.compare_at_price %}
  {% assign discounts = '0,0.10,0.15' | split: ',' %}
  {% assign labels = 'Standard Price,10% extra discount on the total order!,15% extra discount on the total order!'
    | split: ','
  %}

  {% for i in (1..3) %}
    {% assign discount = discounts[i-1] | times: 1.0 %}
    {% assign total_price = base_price | times: i %}
    {% assign discount_amount = total_price | times: discount %}
    {% assign discounted_price = total_price | minus: discount_amount %}
    {% assign label = labels[i-1] %}

    <div class="bundle-option {% if i == 1 %}active{% endif %}" data-tier="{{ i }}">
      <label class="bundle-header">
        <input
          type="radio"
          name="bundle_option"
          value="{{ i }}"
          {% if i == 1 %}
            checked
          {% endif %}
        >
        <div class="custom-radio"></div>

        <div class="bundle-info">
          <div class="bundle-title-row">
            <strong>{{ i }} Pair</strong>

            {% if i == 2 %}
              <div class="tag-wrapper popular-wrapper">
                <span class="tag popular">MOST POPULAR!</span>
              </div>
            {% elsif i == 3 %}
              <div class="tag-wrapper best-wrapper">
                <span class="tag best">BEST DEAL</span>
              </div>
            {% endif %}
          </div>

          <div class="bundle-subtitle">{{ label }}</div>
        </div>

        <div class="bundle-price">
          <span class="price">Tk {{ discounted_price | money }}</span>
          <span class="compare">Tk {{ compare_price | times: i | money }}</span>
        </div>
      </label>

      <div class="variant-selectors">
        <div class="variant-inner">
          {% for j in (1..i) %}
            <div class="variant-row">
              <label>#{{ j }}</label>
              <div>
                {% for option in product.options_with_values %}
                  <div class="product-option">
                    <label for="option-{{ forloop.index0 }}">{{ option.name }}</label>
                    <select
                      id="option-{{ forloop.index0 }}"
                      name="options[{{ option.name }}]"
                      data-option-index="{{ forloop.index0 }}"
                    >
                      {% for value in option.values %}
                        <option
                          value="{{ value | escape }}"
                          {% if value == option.selected_value %}
                            selected
                          {% endif %}
                        >
                          {{ value | escape }}
                        </option>
                      {% endfor %}
                    </select>
                  </div>
                {% endfor %}
              </div>
            </div>
          {% endfor %}
        </div>
      </div>
    </div>
  {% endfor %}

  <button class="add-to-cart">ðŸ›’ Add to cart</button>
</div>

<script>
  /*
  Bundle Accordion (Product Page)
  - Select kora bundle tier expand hobe
  - Baki gulo collapse thakbe
  - Resize e height re-calc hobe
*/
  (function () {
    'use strict';

    // Active tier expand/collapse
    function updateBundleAccordion(selectedTier) {
      document.querySelectorAll('.bundle-option').forEach((option) => {
        const tier = parseInt(option.dataset.tier);
        const container = option.querySelector('.variant-selectors');
        if (!container) return;

        if (tier === selectedTier) {
          option.classList.add('active');
          // Expand: content-er height onujayi max-height set
          container.style.maxHeight = container.scrollHeight + 'px';
        } else {
          option.classList.remove('active');
          // Collapse
          container.style.maxHeight = '0px';
        }
      });
    }

    function initAccordion() {
      // Initial: pre-selected radio detect
      const defaultSelected = document.querySelector('input[name="bundle_option"]:checked');
      if (defaultSelected) {
        updateBundleAccordion(parseInt(defaultSelected.value));
      }

      // Change e update
      document.querySelectorAll('input[name="bundle_option"]').forEach((radio) => {
        radio.addEventListener('change', (e) => {
          updateBundleAccordion(parseInt(e.target.value));
        });
      });

      // Resize e active container-er height re-calc
      window.addEventListener('resize', () => {
        const active = document.querySelector('.bundle-option.active .variant-selectors');
        if (active) active.style.maxHeight = active.scrollHeight + 'px';
      });
    }

    document.addEventListener('DOMContentLoaded', initAccordion);
  })();
</script>

<script>
  /*
  Bundle AJAX Add to Cart (Product Page)
  - Active bundle-er proti row theke option values collect kora
  - Correct variant id match kore
  - Ekbar-e /cart/add.js e multiple line items add
  - Cart count update (optional)
*/
  (function () {
    'use strict';

    // Simple toast (theme jodi snackbar/drawer thake, replace kore niben)
    function toast(msg) {
      alert(msg);
    }

    // Product JSON (inline theke)
    function getInlineProductData() {
      try {
        const el = document.getElementById('product-data');
        return el ? JSON.parse(el.textContent) : null;
      } catch (e) {
        console.warn('Product JSON parse error', e);
        return null;
      }
    }

    // Fallback: URL theke product JSON fetch (jodi inline miss hoy)
    async function fetchProductDataFromHandle() {
      try {
        const parts = window.location.pathname.split('/').filter(Boolean);
        const idx = parts.indexOf('products');
        if (idx === -1 || !parts[idx + 1]) return null;
        const handle = parts[idx + 1];
        const res = await fetch('/products/' + handle + '.js');
        if (!res.ok) return null;
        return await res.json();
      } catch (e) {
        console.warn('Product JSON fetch failed', e);
        return null;
      }
    }

    // Ensure product data (inline priority)
    let productDataCache = null;
    async function ensureProductData() {
      if (productDataCache) return productDataCache;

      const inline = getInlineProductData();
      if (inline) {
        productDataCache = inline;
        return productDataCache;
      }
      const fetched = await fetchProductDataFromHandle();
      if (fetched) {
        productDataCache = fetched;
        return productDataCache;
      }
      return null;
    }

    // option values -> variant match (order must be option1, option2, option3)
    function findVariantByOptions(productData, optionValues) {
      if (!productData || !Array.isArray(productData.variants)) return null;
      return (
        productData.variants.find((v) => {
          for (let i = 0; i < optionValues.length; i++) {
            if ((v['option' + (i + 1)] || '') !== optionValues[i]) return false;
          }
          return true;
        }) || null
      );
    }

    // Active bundle wrapper
    function getActiveBundle() {
      return document.querySelector('.bundle-option.active');
    }

    // Row theke ordered option values (data-option-index onujayi sort)
    function getOptionValuesFromRow(rowEl) {
      const selects = rowEl.querySelectorAll('select[data-option-index]');
      const ordered = Array.from(selects).sort((a, b) => {
        return parseInt(a.dataset.optionIndex) - parseInt(b.dataset.optionIndex);
      });
      return ordered.map((s) => s.value);
    }

    // Active bundle theke items build
    function buildItemsFromActiveBundle(productData) {
      const activeBundle = getActiveBundle();
      if (!activeBundle) throw new Error('Please select a bundle first.');

      const tier = parseInt(activeBundle.dataset.tier);
      const rows = activeBundle.querySelectorAll('.variant-row');
      if (!rows.length) throw new Error('No variant rows found for the selected bundle.');

      const items = [];

      rows.forEach((rowEl, idx) => {
        const optionValues = getOptionValuesFromRow(rowEl);

        // Fallback: jodi kono option nai (single-variant product), first variant use
        if (!optionValues.length && productData.variants && productData.variants.length === 1) {
          const onlyVariant = productData.variants[0];
          if (!onlyVariant.available) {
            throw new Error('Selected variant for row #' + (idx + 1) + ' is out of stock.');
          }
          items.push({
            id: onlyVariant.id,
            quantity: 1,
            properties: {
              Bundle: tier + ' Pair Bundle',
              Row: '#' + (idx + 1),
            },
          });
          return;
        }

        if (!optionValues.length) {
          throw new Error('Please select options for row #' + (idx + 1));
        }

        const variant = findVariantByOptions(productData, optionValues);
        if (!variant) {
          throw new Error('No matching variant found for row #' + (idx + 1));
        }
        if (!variant.available) {
          throw new Error('Selected variant for row #' + (idx + 1) + ' is out of stock.');
        }

        items.push({
          id: variant.id,
          quantity: 1,
          // NOTE: Ekhane properties use koray identical line items merge hobena.
          // Jodi same variant duita row-e select korle merge korte chan, Row property remove kore din.
          properties: {
            Bundle: tier + ' Pair Bundle',
            Row: '#' + (idx + 1),
          },
        });
      });

      return items;
    }

    // POST multiple line items to cart
    async function addItemsToCart(items) {
      const res = await fetch('/cart/add.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
        body: JSON.stringify({ items }),
      });

      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err?.description || 'Failed to add to cart.');
      }

      return res.json();
    }

    // Optional: cart count update (if #cart-count exists)
    async function updateCartCount() {
      try {
        const cart = await fetch('/cart.js').then((r) => r.json());
        const el = document.querySelector('#cart-count');
        if (el) el.textContent = cart.item_count;
      } catch (e) {
        console.warn('Cart count update failed', e);
      }
    }

    function initAddToCart() {
      const btn = document.querySelector('.add-to-cart');
      if (!btn) return;

      btn.addEventListener('click', async (e) => {
        e.preventDefault();

        // Button state
        const oldText = btn.textContent;
        btn.disabled = true;
        btn.textContent = 'Adding...';

        try {
          // Ensure product data
          const productData = await ensureProductData();
          if (!productData) throw new Error('Product data not found. Please include the product JSON.');

          // Build items from current selections
          const items = buildItemsFromActiveBundle(productData);

          // Add to cart via AJAX
          await addItemsToCart(items);

          // Optional: update count / open mini cart
          await updateCartCount();
          // Example (theme specific):
          // if (window.ThemeCart && typeof window.ThemeCart.open === 'function') window.ThemeCart.open();

          toast('Bundle added to cart ðŸŽ‰');
        } catch (err) {
          console.error(err);
          toast(err.message || 'Something went wrong. Please try again.');
        } finally {
          btn.disabled = false;
          btn.textContent = oldText;
        }
      });
    }

    document.addEventListener('DOMContentLoaded', initAddToCart);
  })();
</script>
